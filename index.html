<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>WebAR — GLB Placement Debug (Fixed)</title>

  <!-- MindAR CSS (positions the camera video correctly) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.css">

  <!-- Three pinned for MindAR compatibility -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.152.2/examples/jsm/",
      "mindar-image-three": "https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
    }
  }
  </script>

  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    #container{position:fixed;inset:0}
    #container canvas{position:fixed;inset:0;z-index:1}
    #hint{position:fixed;left:0;right:0;top:8px;text-align:center;color:#fff;opacity:.95;z-index:3}
    #debug{position:fixed;left:8px;top:8px;color:#0ff;background:#002a;padding:6px 8px;border-radius:8px;font:12px/1.2 monospace;z-index:4}
    #ui{position:fixed;left:12px;right:12px;bottom:12px;z-index:4;display:flex;gap:8px;justify-content:center;flex-wrap:wrap}
    button,a.button{padding:10px 14px;border:0;border-radius:12px;font-size:16px;font-weight:600;cursor:pointer;background:#4f46e5;color:#fff;text-decoration:none}
    button.secondary{background:#374151}

    /* Let MindAR's own CSS handle the video. But ensure if video exists it fills the screen */
    .mindar-video, video {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0; /* so canvas (z-index:1) draws on top */
      touch-action: none;
    }
  </style>
</head>
<body>
  <div id="hint">Press Start AR</div>
  <div id="debug">three: … | model: idle</div>
  <div id="container"></div>

  <div id="ui">
    <button id="startBtn">Start AR</button>
    <button id="restartBtn" class="secondary">Restart</button>
    <button id="pingBtn" class="secondary">Ping (Preview GLB)</button>
    <button id="cubeBtn" class="secondary">Test Cube</button>
    <a id="ctaBtn" class="button" href="#" target="_blank" rel="noopener">Visit Site</a>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { MindARThree } from 'mindar-image-three';
    import { GLTFLoader }  from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

    // ===== CONFIG =====
    const CTA_URL    = 'https://example.com';
    const MODEL_URL  = './model.glb'; // must sit next to this file
    const TARGETS    = './targets.mind';
    const FIT_MODE   = 'max';         // 'width' | 'height' | 'max'
    const FIT_SIZE_M = 0.6;
    const MODEL_LIFT = 0.02;
    const ROT_FIX = { x: 90, y: 90, z: 0 };// common GLB fix
    // ==================

    const debugEl = document.getElementById('debug');
    const updateDebug = (msg) => {
      debugEl.textContent = `three: ${THREE.REVISION} | ${msg}`;
    };
    updateDebug('model: idle');

    // Basic UI
    document.getElementById('ctaBtn').href = CTA_URL;
    const container  = document.getElementById('container');
    const hint       = document.getElementById('hint');
    const startBtn   = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const pingBtn    = document.getElementById('pingBtn');
    const cubeBtn    = document.getElementById('cubeBtn');

    // MindAR + THREE
    const mindar = new MindARThree({
      container,
      imageTargetSrc: TARGETS,
      uiLoading:'no', uiScanning:'no', uiError:'no',
      warmupTolerance: 2, missTolerance: 8
    });
    const { renderer, scene, camera } = mindar;
    renderer.setClearColor(0x000000, 0);
    renderer.domElement.style.touchAction = 'none';
    camera.near = 0.01; camera.far = 500; camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight, false);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(1,2,1);
    scene.add(dir);

    // Anchor
    const anchor = mindar.addAnchor(0);

    // Add visible axes on anchor so you can see where anchor is
    const anchorAxes = new THREE.AxesHelper(0.2);
    anchor.group.add(anchorAxes);

    // GLB loader
    const gltfLoader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
    draco.setDecoderConfig({ type: 'js' });
    gltfLoader.setDRACOLoader(draco);

    let modelPrefab = null;
    let placedInstance = null;
    let spawned = false;
    let rescuePreview = null;

    function makeRenderable(object){
      object.traverse(o=>{
        // avoid frustum cull hiding small objects
        o.frustumCulled = false;
        if (o.isMesh && o.material){
          // ensure double-sided so model isn't invisible from the camera side
          const mats = Array.isArray(o.material)? o.material : [o.material];
          mats.forEach(m=>{
            m.side = THREE.DoubleSide;
            if('toneMapped' in m) m.toneMapped = true;
          });
        }
      });
    }
    function centerByBounds(object){
      const box = new THREE.Box3().setFromObject(object);
      if (!isFinite(box.min.x)) return;
      const center = box.getCenter(new THREE.Vector3());
      object.position.sub(center);
      object.updateMatrixWorld(true);
    }
    function fitByBounds(object, mode, desired){
      const box = new THREE.Box3().setFromObject(object);
      if (!isFinite(box.min.x)) return;
      const s = box.getSize(new THREE.Vector3());
      let current = s.x;
      if (mode==='height') current = s.y;
      if (mode==='max')   current = Math.max(s.x, s.y, s.z);
      const scale = current>1e-6 ? desired/current : 1;
      object.scale.multiplyScalar(scale);
      object.updateMatrixWorld(true);
    }

    async function loadModel(){
      if (modelPrefab) return;
      updateDebug('model: loading…');
      console.log('Loading GLB:', MODEL_URL);
      await new Promise((resolve,reject)=>{
        gltfLoader.load(
          MODEL_URL,
          (gltf)=>{
            modelPrefab = gltf.scene;
            makeRenderable(modelPrefab);
            updateDebug('model: loaded ✓');
            console.log('GLB loaded ✓', modelPrefab);
            resolve();
          },
          (xhr)=>{ if (xhr.total){ hint.textContent = `Loading model… ${Math.round((xhr.loaded/xhr.total)*100)}%`; } },
          (err)=>{ updateDebug('model: ERROR (see console)'); console.error('Model load error:', err); hint.textContent='Failed to load model'; reject(err); }
        );
      });
    }

    function showRescuePreview(seconds=4){
      if (!modelPrefab) return;
      if (rescuePreview) camera.remove(rescuePreview);
      rescuePreview = modelPrefab.clone(true);
      centerByBounds(rescuePreview);
      fitByBounds(rescuePreview, FIT_MODE, FIT_SIZE_M);
      rescuePreview.rotation.set(ROT_FIX.x, ROT_FIX.y, ROT_FIX.z);
      rescuePreview.position.set(0, -0.05, -0.8);
      camera.add(rescuePreview);
      setTimeout(()=>{ if(rescuePreview){ camera.remove(rescuePreview); rescuePreview=null; } }, seconds*1000);
    }

    function spawnTestCubeAtAnchor(){
      const mat = new THREE.MeshStandardMaterial({ color: 0xff00ff, metalness:0, roughness:0.4 });
      const cube = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), mat);
      cube.position.set(0, 0.1 + MODEL_LIFT, 0);
      anchor.group.add(cube); // attached to anchor
      return cube;
    }

    // Anchor events
    anchor.onTargetFound = async ()=>{
      console.log("Target FOUND");
      hint.textContent = 'Tracking ✓';
      updateDebug(`model: ${modelPrefab?'loaded':'idle'}`);
      if (spawned) return;

      // ensure model loaded
      await loadModel().catch(()=>{});

      // spawn debug helper cube (always)
      const debugCube = spawnTestCubeAtAnchor();
      debugCube.name = 'DEBUG_CUBE_MAGENTA';
      console.log('Debug cube added to anchor');

      if (modelPrefab){
        placedInstance = modelPrefab.clone(true);
        // center + fit
        centerByBounds(placedInstance);
        fitByBounds(placedInstance, FIT_MODE, FIT_SIZE_M);
        // apply a safe rotation (many exporters need -90deg)
        placedInstance.rotation.set(ROT_FIX.x, ROT_FIX.y, ROT_FIX.z);
        // make sure visible and put a small lift above the plane
        placedInstance.position.set(0, MODEL_LIFT, 0);
        placedInstance.visible = true;
        anchor.group.add(placedInstance); // attach directly to anchor
        console.log('Model attached to anchor ✓', placedInstance);
      } else {
        console.warn('Model prefab missing — only debug cube placed');
      }

      spawned = true;
      hint.textContent = 'Placed ✓ Move away to test';
    };

    anchor.onTargetLost = ()=>{
      console.log("Target LOST");
      hint.textContent = spawned ? 'Model placed — move around freely' : 'Move back to the target…';
    };

    // Buttons
    startBtn.addEventListener('click', async ()=>{
      startBtn.disabled = true; startBtn.textContent = 'Starting…';
      try{
        await mindar.start();
        renderer.setAnimationLoop(()=>renderer.render(scene, camera));
        startBtn.textContent = 'Running…';
        hint.textContent = 'Scan the image target…';
        updateDebug(`model: ${modelPrefab?'loaded':'idle'} (three ${THREE.REVISION})`);
      }catch(e){
        console.error('mindar.start() error:', e);
        startBtn.disabled = false; startBtn.textContent = 'Start AR (Retry)';
        hint.textContent = 'Start failed — check camera permission';
      }
    });

    restartBtn.addEventListener('click', async ()=>{
      try { await mindar.stop(); } catch (err) { console.warn('stop error', err); }
      renderer.setAnimationLoop(null);
      // clear anchor children (keeps anchor.group reference)
      while(anchor.group.children.length) anchor.group.remove(anchor.group.children[0]);
      // re-add axes so you can always see orientation after restart
      anchor.group.add(anchorAxes);
      spawned = false;
      placedInstance = null;
      await mindar.start();
      renderer.setAnimationLoop(()=>renderer.render(scene, camera));
      hint.textContent = 'Point your camera at the target image';
    });

    pingBtn.addEventListener('click', async ()=>{
      await loadModel().catch(()=>{});
      showRescuePreview(4);
    });

    cubeBtn.addEventListener('click', ()=>{
      spawnTestCubeAtAnchor();
      hint.textContent = 'Test Cube spawned at anchor';
    });

    // Resize
    new ResizeObserver(()=>renderer.setSize(container.clientWidth, container.clientHeight, false)).observe(container);

    // -- helpful console reminder
    console.log('%cWebAR debug helper loaded','color:cyan;font-weight:700');
    console.log('Make sure: 1) model.glb and targets.mind are in the same folder as this HTML file');
    console.log('2) You run via local server (file:// usually blocks requests).');
    console.log('If camera remains black: check the console for camera permission or getUserMedia errors.');
  </script>
</body>
</html>
